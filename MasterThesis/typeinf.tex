% 
% Type inference algorithm draft (for Oishi System)
%
\documentclass{jsarticle}
\addtolength{\topmargin}{-2cm}
\addtolength{\textwidth}{3cm}
\addtolength{\oddsidemargin}{-1.5cm}
\usepackage{amsmath,amssymb}
%\usepackage[dvipdfm]{graphicx}

\newenvironment{vq}
{%begin
\VerbatimEnvironment \begin{screen} \begin{quote} \begin{Verbatim}
}
{%end
\end{Verbatim} \end{quote} \end{screen}
}

\usepackage{proof}

\usepackage{theorem}
\newtheorem{theorem}{theorem}[section]

\newcommand\greaterthan{\ge}
\newcommand\codeT[2]{\langle {#1} \rangle^{#2}}
%\newcommand*\defeq{\stackrel{\text{def}}{=}}
\newcommand\funT[3]{{#1}\stackrel{#3}{\to}{#2}}
\newcommand\Int{\mbox{\texttt{Int}}}
\newcommand\Bool{\mbox{\texttt{Bool}}}

\overfullrule=0pt

\begin{document}

\begin{center}
Oishi Type System に対する型推論アルゴリズム \\
2016/11/19
\end{center}

\section{型システム}

いまのところ、2016/09JSSST大会バージョンものとする。

\section{型推論アルゴリズム}

概要: 以下の2ステップから構成
\begin{itemize}
\item 制約生成:与えられた項にたいして、(型およびクラシファイアに関する)制約を返す。
\item 制約を解く。
\end{itemize}

\subsection{制約生成}

これは、もの型システム($T_1$とする)を
「トップダウンでの制約生成向け型システム($T_2$とする)」に変
形することであたえる。

$T_2$の設計指針:
\begin{itemize}
\item $T_1$と$T_2$は「型付けできる」という関係として等価である。
\item $T_2$は、term-oriented である。
(結論側の式のトップレベルの形だけで、どの型付けルールを適用可能か、一意的にわかる。)
\item $T_2$は、制約生成をする。
(結論側の式の要素は変数として、
「それがこういう形でなければいけない」という条件は、制約の形で「生成」する。)
\end{itemize}

以上をどう満たすか？ ポイントは、subsumption rule の適用タイミング(な
るべく subsumption rule を適用するのを避けたい)である。

\subsection{型システム$T_2$の導入}

subsumption rule が出現する場所を限定することができる．
 特に，ルールと，その直後に subsumption がつかわれる場合を考えてみよう．
以下で，「var1」等といった表記は，
「もともとあるver1ルールを subsumption規則と組み合わせた形に改訂したも
  の」である．
また，横棒の右に書いてあるConstr;... は(ルールを下から上にむけて
使うとき)，Constr 以下の制約が生成される，という意味である．

(var1)
\[
\infer[Constr;~\Gamma \models t \greaterthan t']
      {\Gamma \vdash x:t;~\sigma}
      {(x:t') \in \Gamma
      }
\]

(var2)

\[
\infer[Constr;~\Gamma \models \gamma \greaterthan \gamma']
       {\Gamma \vdash^{\gamma} u:t;~\sigma}
       {(u:t)^{\gamma'} \in \Gamma
       }
\]

(const)

\[
\infer[Constr;~\Gamma \models t \greaterthan t^c]
       {\Gamma \vdash^{L} c:t;~\sigma}
       {}
\]

(app)

\[
\infer[Constr;~\Gamma \models t \greaterthan t_1]
       {\Gamma \vdash^L e_1 \, e_2 : t;~\sigma}
       {\Gamma \vdash^L e_1 : t_2 \to t_1;~\sigma
       &\Gamma \vdash^L e_2 : t_2;~\sigma
       }
\]

(lambda1)

\[
\infer[Constr;~t=\funT{t_1}{t_2}{\sigma}]
       {\Gamma \vdash \lambda x.e : t;~\sigma}
       {\Gamma,~x:t_1 \vdash e : t_2;~\sigma'}
\]

(lambda2)

\[
\infer[Constr;~t=\funT{t_1}{t_2}{}]
       {\Gamma \vdash^\gamma \lambda u.e : t;~\sigma}
       {\Gamma,~(u:t_1)^\gamma \vdash^\gamma e : t_2;~\sigma'}
\]

(if)

\[
\infer[Constr;~(none)]
       {\Gamma \vdash^L
         \textbf{if}~e_1 \textbf{then}~e_2 \textbf{else}~e_3 ~:~t; ~ \sigma}
       {\Gamma \vdash^L e_1 : \Bool;~\sigma
       &\Gamma \vdash^L e_2 : t;~\sigma
       &\Gamma \vdash^L e_3 : t;~\sigma
       }
\]

(code-lambda)

\[
\infer[Constr;~t=\codeT{t_1 \to t_2}{\gamma}]
       {\Gamma \vdash^L \underline{\lambda}x.e ~:~t;~\sigma}
       {\Gamma,\gamma' \greaterthan \gamma,x:\codeT{t_1}{\gamma'}
         \vdash^L e : \codeT{t_2}{\gamma_1};~\sigma
       }
\]

(reset0)

\[
\infer[Constr;~t=\codeT{t'}{\gamma}]
       {\Gamma \vdash \textbf{reset0}~e ~:~ t; ~\sigma}
       {\Gamma \vdash e:\codeT{t'}{\gamma};~\codeT{t}{\gamma},\sigma
       }
\]

(shift0)


(throw0)

\subsection{制約解消}

\end{document}
