% 
% Type inference algorithm draft (for Oishi System)
%
\documentclass[dvipdfmx]{jsarticle}

\usepackage[dvipdfmx]{graphicx,color}
\addtolength{\topmargin}{-2cm}
\addtolength{\textwidth}{3cm}
\addtolength{\oddsidemargin}{-1.5cm}

\usepackage{theorem}
\usepackage{amsmath,amssymb}
\usepackage{ascmac}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{listings,jlisting}
\usepackage{here}

\newenvironment{vq}
{%begin
\VerbatimEnvironment \begin{screen} \begin{quote} \begin{Verbatim}
}
{%end
\end{Verbatim} \end{quote} \end{screen}
}
\newtheorem{theorem}{theorem}[section]

\input{newcommand}

\newcommand\smallerscope[2]{#1 \ord #2}
\newcommand\greaterscope[2]{#2 \ord #1}
\newcommand\longer[2]{{#1} \ord {#2}}
%\newcommand*\defeq{\stackrel{\text{def}}{=}}
\newcommand\Int{\mbox{\texttt{Int}}}
\newcommand\Bool{\mbox{\texttt{Bool}}}

\overfullrule=0pt

\begin{document}

\begin{center}
Oishi Type System に対する型推論アルゴリズム \\
2016/11/19
\end{center}

\section{型システム}

いまのところ、2016/09JSSST大会バージョンものとする。

\section{型推論アルゴリズム}

概要: 以下の2ステップから構成
\begin{itemize}
\item 制約生成:与えられた項にたいして、(型およびクラシファイアに関する)制約を返す。
\item 制約を解く。
\end{itemize}

\subsection{制約生成}

これは、もの型システム($T_1$とする)を
「トップダウンでの制約生成向け型システム($T_2$とする)」に変
形することであたえる。

$T_2$の設計指針:
\begin{itemize}
\item $T_1$と$T_2$は「型付けできる」という関係として等価である。
\item $T_2$は、term-oriented である。
(結論側の式のトップレベルの形だけで、どの型付けルールを適用可能か、一意的にわかる。)
\item $T_2$は、制約生成をする。
(結論側の式の要素は変数として、
「それがこういう形でなければいけない」という条件は、制約の形で「生成」する。)
\end{itemize}

以上をどう満たすか？ ポイントは、subsumption rule の適用タイミング(な
るべく subsumption rule を適用するのを避けたい)である。

\subsection{型システム$T_2$の導入}

subsumption rule が出現する場所を限定することができる．
 特に，ルールと，その直後に subsumption がつかわれる場合を考えてみよう．
以下で，「var1」等といった表記は，
「もともとあるver1ルールを subsumption規則と組み合わせた形に改訂したも
  の」である．
また，横棒の右に書いてあるConstr;... は(ルールを下から上にむけて
使うとき)，Constr 以下の制約が生成される，という意味である．

また、型$t_1, t_2$に対する$\longer{}{}$の記号は以下の意味であるが、
とりあえず、(以下の意味にしたがって分解はせずに)
$\longer{t_1}{t_2}$ の形のまま、制約として生成する。
\begin{itemize}
\item $\longer{\codeT{t_1}{\gamma_1}}{\codeT{t_2}{\gamma_2}}$
は、「$t_1=t_2$ かつ $\longer{\gamma_1}{\gamma_2}$
\item $\codeT{t}{\gamma}$の形でない$t_1,t_2$に対しては、
$t_1 = t_2$。
\end{itemize}
(型推論のプロセスの最中では、$t_1, t_2$ はメタ型変瑞。洽筅キ、譴此その場合、どちらの形かは決定できないので、$\longer{t_1}{t_2}$を
上記の意味にしたがって、「ほどく」ことはできない。なので、
$\longer{t_1}{t_2}$という形のまま制約として生成する。)

(亀山メモ:
ただ、もしかすると、
「レベル0の型変数」と「レベル1の型変数」を最初からわけておく方法もある
かもしれない。そうすると、上記はとける？)

(var1)
\[
\infer[Constr;~\Gamma \models \longer{t}{t'}]
      {\Gamma \vdash x:t;~\sigma}
      {(x:t') \in \Gamma
      }
\]

(var2)

\[
\infer[Constr;~\Gamma \models \longer{\gamma}{\gamma'}]
       {\Gamma \vdash^{\gamma} u:t;~\sigma}
       {(u:t)^{\gamma'} \in \Gamma
       }
\]

(const)

\[
\infer[Constr;~\Gamma \models \longer{t}{t^c}]
       {\Gamma \vdash^{L} c:t;~\sigma}
       {}
\]

(app)

\[
\infer[Constr;~\Gamma \models \longer{t}{t_1}]
       {\Gamma \vdash^L e_1 \, e_2 : t;~\sigma}
       {\Gamma \vdash^L e_1 : t_2 \to t_1;~\sigma
       &\Gamma \vdash^L e_2 : t_2;~\sigma
       }
\]

(lambda0)

\[
\infer[Constr;~t=\funT{t_1}{t_2}{\sigma'}]
       {\Gamma \vdash \lambda x.e : t;~\sigma}
       {\Gamma,~x:t_1 \vdash e : t_2;~\sigma'}
\]

(lambda1)

\[
\infer[Constr;~t=\funT{t_1}{t_2}{}]
       {\Gamma \vdash^\gamma \lambda u.e : t;~\sigma}
       {\Gamma,~(u:t_1)^\gamma \vdash^\gamma e : t_2;~\sigma'}
\]

(if)

\[
\infer[Constr;~(none)]
       {\Gamma \vdash^L
         \textbf{if}~e_1 \textbf{then}~e_2 \textbf{else}~e_3 ~:~t; ~ \sigma}
       {\Gamma \vdash^L e_1 : \Bool;~\sigma
       &\Gamma \vdash^L e_2 : t;~\sigma
       &\Gamma \vdash^L e_3 : t;~\sigma
       }
\]

(code-lambda)

\[
\infer[Constr;~\longer{t}{\codeT{t_1 \to t_2}{\gamma}}]
       {\Gamma \vdash^L \underline{\lambda}x.e ~:~t;~\sigma}
       {\Gamma,\longer{\gamma'}{\gamma},x:\codeT{t_1}{\gamma'}
         \vdash^L e : \codeT{t_2}{\gamma'};~\sigma
       }
\]

(reset0)

\[
\infer[Constr;~\longer{t}{\codeT{t'}{\gamma}}]
       {\Gamma \vdash \textbf{reset0}~e ~:~ t; ~\sigma}
       {\Gamma \vdash e:\codeT{t'}{\gamma};~\codeT{t'}{\gamma},\sigma
       }
\]

(shift0)

\[
\infer[Constr;~\longer{t}{\codeT{t_1}{\gamma_1}},~ t_2 =\codeT{t_0}{\gamma_0}]
  {\Gamma \vdash \shiftz{k}{e} : t~;~ t_2,\sigma}
  {\Gamma,~k:\contT{\codeT{t_1}{\gamma_1}}{\codeT{t_0}{\gamma_0}}{\sigma}
      \vdash e : \codeT{t_0}{\gamma_0} ; \sigma
      & \Gamma \models \longer{\gamma_1}{\gamma_0}
    }
\]


(throw0)

\[
\infer[Constr;~\longer{t}{\codeT{t_0}{\gamma_2}}]
  {\Gamma,~k:\contT{\codeT{t_1}{\gamma_1}}{\codeT{t_0}{\gamma_0}}{\sigma}
      \vdash \throw{k}{v} : t ; \sigma}
  {\Gamma
      \vdash v : \codeT{t_1}{\gamma_1 \cup \gamma_2} ; \sigma
      & \Gamma \models \gamma_2 \ord \gamma_0
  }
\]

(code)

\[
\infer[Constr;~\longer{t}{\codeT{t_1}{\gamma}}]
       {\Gamma \vdash \code{e} : t;~\sigma}
       {\Gamma \vdash^\gamma e : t_1;~\sigma}
\]



\end{document}
