# 修論発表スライド
## タイトル
安全なコード移動が可能なコード生成言語の型システムの設計と実装
発表時間：20分
質疑応答：8分

### メモ
早めにこの研究の肝，面白いところを伝えたい

ソフトウェア学会並の詳しさで大丈夫？
* 型推論のところを主に説明したい

## 構成
* この修論で達成したこと
* 問題点
* どう解決したか
  * アイデア
  * 実装とかの例とか出せれば良い

## ストーリー
### 目的 aim 2分
* コード生成言語に s0/r0を入れた言語の作成
および
* コントロールオペレータによるコード移動を **安全に** 行うための型システム，型推論アルゴリズムの開発

### 準備 background 3分
* 多段階let 挿入をコード生成 + s0/r0 で実現

### 問題点 problem 3分
* scope extrusion
* コード移動をすると，評価前と評価後でスコープの順番が変わる

### 解決策 solution 4分
* 須藤らの体系をもとに，ECを用いた型システムを作る

* 須藤らの研究
    * 副作用とコード生成を組み合わせた場合に発生する scope extrusion は,
      未束縛の変数が,あ るべき範囲の外側に染み出してしまうという問題だった.
      そこで,コードレベルのラムダ抽 象 λ_ x. e の x の型が,
      固有変数条件を満たさなければならないという制約を加え,この問題を 解決することとした.
* EC付きの型システムの説明

* union を導入

### 解決方法 howdo 6分
* 型システムの説明
* sigma-part answer タイプ
* 型付けの例

* 型推論
* 制約生成
  * subsumption 規則をあらゆる規則に付加させて型推論用(制約を生成する)の型システムT2を作成．
    型付け規則を一意に適用できるようにした
  * (型に関する順序の導入) t1 > t2について
* 制約解消  例で説明 主に EC の不等式を解消できるような例を考える 実装は制約生成まで
  * = のものに対しては unificationで解く

    単一化(unification):  'y->(int->'w)->'x と ('x->'z)->('x->'z) を単一化する問題というのは、 「この中にあらわれる型変数に、うまい型を代入すると、この2つの型は、同じ型になるかどうか」 を判定することである。 この場合の答えとしては、['x:=int->'w, 'y:=(int->'w)->(int->'w), 'z:=int->'w] とすることにより、両辺とも同じ型になるので、YES である。 なお、'x:=int->'w というのは、型変数'x を int->'w 型にするという 代入(substitution)を表している。

    さて、単一化関数について記述しよう。

    * 単一化関数の入力: 2つの型(型変数を含むかもしれない)
    * 単一化関数の出力: 「YES」と型変数に対する代入、 あるいは、「NO」
    * 単一化がおこなうこと: 入力となる2つの型が、 その中に含まれる型変数を適当な型に代入する事により、 一致することがあるかどうか、判定する。一致する場合は、 さらに、どのような代入で一致するかも答える。

    さて、「YES」という判定結果のとき、対応する代入は1つとは限らないが、 例によって、「最も一般的な代入」は(実質的に)一意的であるので、 問題は起きない。
    なお、通常、単一化問題は、2つの型の間だけでなく、 (t1=t2, t3=t4, ...) という、たくさんの(型の間の)単一化問題として 定式化される。
  * > のものに対しては 主に EC(d) の不等式の解き方について話す

### まとめ conc 1分


## 内容 20分-18分
keywords: let挿入 コード生成 s0/r0 EC union
### 概要
  * プログラムを生成するプログラム(コード生成)の安全性を保証
  * コード生成における効率的なプログラム技法のひとつである多段階let 挿入を安全に扱うための型システムを構築

### 準備
  * コード生成の例
  * shift0/reset0を用いることで，多段階let挿入が可能となることの例

### **問題**
  * let 挿入行うコード例 エラーとなるような例を出して，
    この例には型をつけたい，この例には型がつかないようにしたい
    * 一般にコード生成の前の段階で安全なコードかどうかを判断したい -> コンパクトにいう
  * 以下技術的なこと
  * 先行研究のEC を利用したスコープ表現を用いる型システムの導入をする．
  しかし，多段階let挿入を行うとコード内のスコープの範囲が逆転してしまう．

### **解決方法**
  * 多段階let 挿入を実現するために s0/r0を導入
  * ECに対して， union を導入することで，スコープの範囲の逆転に対応 ここまでが中間発表と説明

### やったこと，できること
  * T_1 での型付け例
    * 手で型付けはできないので，型推論をしたい
  * 型推論アルゴリズムの導入(制約生成，制約解消) (T_1 ではなぜできないか．すべての場所でsubsumption を使う必要なく，バックトラックの必要なくトップレベルの項が与えられれば一意的に適用する型付け規則が決まるようなT_2 を作成) T_1 からT_2 をどう変換したかの例
  * T_2とは制約生成用，subsumption をくっつけたもの(一意的にしたいから)
  * 型，sigma-part のsubsumption についてのディスカッション(sigma-partの説明はしてないのでここはこういう問題もあったのを口で説明？) -> やめる
  * 制約解消
  * (型推論例は必要っぽい？)
  * 実装は，制約生成までした．(制約解消はまだ)

### まとめ

### appendix 質問用
  * shift/reset と shift0/reset0 の違い

  * どれくらい調べたの？
    * バインダーを行ったり来たり，飛び越えたりするのが，重要．
    変数束縛のところに関係するものについては調べてる．それが本質的．
    * いくつか調べておく
    * let をたくさんネストさせるようなコード例を動かしたりするかも

* 質問に対しての返答は対策をする
  * T_1 とT_2 の同値性についてなど
  T_2 に対しては subsumption を機械的に型付け規則につけている
  T_2 のフォーマルな同値性については証明はしていないが．


## 制約解消のところ
型推論の制約解消部分のスライド案

---------------------------------------------------------------------
* 制約の解消

生成された制約 Δ |= C

   仮定Δ
     ECに対する順序        d >= e
   制約C
    型                  t0 = t1    t0 >= t1
    識別子               γ0 = γ1   γ0 >= γ1
    エフェクト(型の列)     σ0 = σ1

この制約に対する解があるかどうかを判定する。

  型に対する単一化等をおこなう。
  ここでは、識別子の不等式制約の解消について説明
---------------------------------------------------------------------
* 制約の解消： 識別子の不等式制約の解消

この時点で残る制約 Δ |= C

   仮定Δ:  d >= e の有限集合  (d は 識別子定数)
   制約C:  e1 >= e2  の有限集合
   e,e1,e2... 識別子を表す式  e::= d | x | e ∪ e

制約解消アルゴリズム (一部)
   (* e >= e )      ---->   除去して再帰
   * d1 >= d2       ---->   Δ を使って判定
   * e1 >= e2 ∪ e3  ---->   e1 >= e2 かつ e1 >= e3
   * e1 ∪ e2 >= d   ---->   e1 >= d または e2 >= d
   * 変数 x の除去
       e1 >= x  x >= d1    =>   e1 >= d1  e2 >= d1
       e2 >= x  x >= d2         e1 >= d2  e2 >= d2
                x >= y          e1 >= y   e2 >= y
		      		[x := d1 ∪ d2 ∪ y]

==> 制約を満たす解が存在するかどうかは判定できる。
    解は1つとは限らない。
---------------------------------------------------------------------
