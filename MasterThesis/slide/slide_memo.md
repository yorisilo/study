# 修論発表スライド
## タイトル
安全なコード移動が可能なコード生成言語の型システムの設計と実装
発表時間：20分
質疑応答：8分

### TODO
#### 20170124
* スライド作成：制約解消の例を作る．

このような制約が生成されました．として，
classifier の不等式の制約解消のアルゴリズムの動きを例(ほぼすべての場合を通るような例を作る)で示す．
他は解いておく．で，解けたら，最終的にこのような代入が出力されるよーというような流れ

* 型システムの sigma-part は薄い色にする．グレーとか

### メモ
早めにこの研究の肝，面白いところを伝えたい

ソフトウェア学会並の詳しさで大丈夫？
* 型推論のところを主に説明したい

### やったこと，できること
  * T_1 での型付け例
    * 手で型付けはできないので，型推論をしたい
  * 型推論アルゴリズムの導入(制約生成，制約解消) (T_1 ではなぜできないか．すべての場所でsubsumption を使う必要なく，バックトラックの必要なくトップレベルの項が与えられれば一意的に適用する型付け規則が決まるようなT_2 を作成) T_1 からT_2 をどう変換したかの例
  * T_2とは制約生成用，subsumption をくっつけたもの(一意的にしたいから)
  * 型，sigma-part のsubsumption についてのディスカッション(sigma-partの説明はしてないのでここはこういう問題もあったのを口で説明？) -> やめる
  * 制約解消
  * (型推論例は必要っぽい？)
  * 実装は，制約生成までした．(制約解消はまだ)

## 構成
* この修論で達成したこと
* 問題点
* どう解決したか
  * アイデア
  * 実装とかの例とか出せれば良い

## ストーリー
1. 多段階let挿入等ができるような(実行効率の良い)コード生成言語を作りたい

1. s0/r0 を使ってできるようにする

1. 安全性は型システムで保証する

1. コード移動には危険性が伴う(コード生成後にscope extrusionが起きてしまうかもしれない)

1. 解決方法を提示する： 須藤らの研究をもとに ECを用いた型システムを作る．
   それに Union を追加する

1. Unionを導入したコード移動に対応する型システムの説明
   `Reset0`, `Shift0`, `Throw` 規則の説明

1. `Throw` 規則のUnion等については図を用いて説明？ 次の型付け図の例のところで説明する？

1. 型付け図の例 scope extrusionに対応していることを例で確認，および， `Throw` 規則での Union を図を用いて説明？

1. 型付けは手で行うのはきついので，型推論アルゴリズムを作った

1. 型推論は
   制約生成
   制約解消からなる

1. 制約生成の説明：制約生成用の型システムT2の作成

1. 制約解消の説明：出てきた制約をがんばって解くよ
   それを例を通して説明

1. まとめ

## 内容
keywords: let挿入 コード生成 s0/r0 EC union

### 目的 aim 2分
* コード生成言語に s0/r0を入れた言語の作成
および
* コントロールオペレータによるコード移動を **安全に** 行うための型システム，型推論アルゴリズムの開発

### 準備 background 3分
* 多段階let 挿入をコード生成 + s0/r0 で実現

### 問題点 problem 3分
* scope extrusion
* コード移動をすると，評価前と評価後でスコープの順番が変わる

### 解決策 solution 4分
* 須藤らの体系をもとに，ECを用いた型システムを作る

* 須藤らの研究
    * 副作用とコード生成を組み合わせた場合に発生する scope extrusion は,
      未束縛の変数が,あ るべき範囲の外側に染み出してしまうという問題だった.
      そこで,コードレベルのラムダ抽 象 λ_ x. e の x の型が,
      固有変数条件を満たさなければならないという制約を加え,この問題を 解決することとした.

* code + s0/r0 のEC付き型システムの説明
  * union を導入
  * sigma-part answer タイプについては説明しない．

* 型付けの例
  ここで，union について図を用いて説明する + scope extrusion が起きないときには型が付く(安全だから)．起きるときは型が付かない(危険だから)．の説明をする．

### メインディッシュ(型推論) main_dish 6分
* 型推論
  * 制約生成
    * subsumption 規則をあらゆる規則に付加させて型推論用(制約を生成する)の型システムT2を作成．
    型付け規則を一意に適用できるようにした
    * (型に関する順序の導入) `t1 > t2` について
  * 制約解消  例で説明 主に EC の不等式を解消できるような例を考える 実装は制約生成まで
    * `=` のものに対しては unificationで解く
    * `>` のものに対しては 主に EC(d) の不等式の解き方について話す

    * 例を用いてEC(d) の不等式の解き方について話す．

### まとめ conc 1分

### appendix 質問用 質問に対しての返答の対策をする
* shift/reset と shift0/reset0 の違い
s0/r0 を選んだ理由を言う

* どれくらい調べたの？
  * バインダーを行ったり来たり，飛び越えたりするのが，重要．
    変数束縛のところに関係するものについては調べてる．それが本質的．
  * いくつか調べておく．typeref.ml でいくつか制約を生成する
  * let をたくさんネストさせるようなコード例を動かしたりするかも

* 制約生成は正しいか

T1 とT2 は非常に似通っていて正しさをチェックしようと思えばできる

* 型システムについて
  * T_1 とT_2 の同値性についてなど
  T_2 に対しては subsumption を機械的に型付け規則につけている
  T_2 のフォーマルな同値性については証明はしていないが．
  * unionが必要な理由は？
  大会のスライドを使う
    * throw のところの説明をする．
      図で説明して直感を説明することが必要っぽい

* 証明ってどれくらいしたの？


* 実装はなんでそこまで？

* 単一化ってどうするの？
  単一化(unification):  'y->(int->'w)->'x と ('x->'z)->('x->'z) を単一化する問題というのは、 「この中にあらわれる型変数に、うまい型を代入すると、この2つの型は、同じ型になるかどうか」 を判定することである。 この場合の答えとしては、['x:=int->'w, 'y:=(int->'w)->(int->'w), 'z:=int->'w] とすることにより、両辺とも同じ型になるので、YES である。 なお、'x:=int->'w というのは、型変数'x を int->'w 型にするという 代入(substitution)を表している。

    さて、単一化関数について記述しよう。

    * 単一化関数の入力: 2つの型(型変数を含むかもしれない)
    * 単一化関数の出力: 「YES」と型変数に対する代入、 あるいは、「NO」
    * 単一化がおこなうこと: 入力となる2つの型が、 その中に含まれる型変数を適当な型に代入する事により、 一致することがあるかどうか、判定する。一致する場合は、 さらに、どのような代入で一致するかも答える。

    さて、「YES」という判定結果のとき、対応する代入は1つとは限らないが、 例によって、「最も一般的な代入」は(実質的に)一意的であるので、 問題は起きない。
    なお、通常、単一化問題は、2つの型の間だけでなく、 (t1=t2, t3=t4, ...) という、たくさんの(型の間の)単一化問題として 定式化される。

* answer type の列ってなに？

* 固有変数条件を導入した理由は？

* subsumption 規則とは？


## 型推論の制約解消部分のスライド案

---------------------------------------------------------------------
* 制約の解消

生成された制約 Δ |= C

   仮定Δ
     ECに対する順序        d >= e
   制約C
    型                  t0 = t1    t0 >= t1
    識別子               γ0 = γ1   γ0 >= γ1
    エフェクト(型の列)     σ0 = σ1

この制約に対する解があるかどうかを判定する。

  型に対する単一化等をおこなう。
  ここでは、識別子の不等式制約の解消について説明
---------------------------------------------------------------------
* 制約の解消： 識別子の不等式制約の解消

この時点で残る制約 Δ |= C

   仮定Δ:  d >= e の有限集合  (d は 識別子定数)
   制約C:  e1 >= e2  の有限集合
   e,e1,e2... 識別子を表す式  e::= d | x | e ∪ e

制約解消アルゴリズム (一部)
   (* e >= e )      ---->   除去して再帰
   * d1 >= d2       ---->   Δ を使って判定
   * e1 >= e2 ∪ e3  ---->   e1 >= e2 かつ e1 >= e3
   * e1 ∪ e2 >= d   ---->   e1 >= d または e2 >= d
   * 変数 x の除去
       e1 >= x  x >= d1    =>   e1 >= d1  e2 >= d1
       e2 >= x  x >= d2         e1 >= d2  e2 >= d2
                x >= y          e1 >= y   e2 >= y
		      		[x := d1 ∪ d2 ∪ y]

==> 制約を満たす解が存在するかどうかは判定できる。
    解は1つとは限らない。
---------------------------------------------------------------------
