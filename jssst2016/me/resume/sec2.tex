% section 2

\section{コード生成とlet挿入}

コード生成、すなわち、プログラムによるプログラム(コード)の生成の手法は、
対象領域に関する知識、実行環境、利用可能な計算機リソースなどのパラメー
タに特化した(実行性能の高い)プログラムを生成する目的で広く利用されている。
生成されるコードを文字列として表現する素朴なコード生成法では、
構文エラーなどのエラーを含むコードを生成してしまう危険があり、さらに、
生成されたコードのディバッグが非常に困難であるという問題がある。

これらの問題を解決するため、
コード生成器(コード生成をするプログラム)を記述するためのプログラム言語
の研究が行わており、特に静的な型システムのサポートを持つ言語として、
MetaOCaml, Template Haskell, Scala LMSなどがある。

本研究は、
MetaOCaml などの値呼び関数型言語に基づいたコード生成言語を対象としているが、
言語のプレゼンテーションでは、先行研究にならい
コードコンビネータ(Code Combinator)方式を使う。MetaML/MetaOCamlなどにおける擬似引用
(Quasi-quotation)方式は、コード生成に関する言語要素として
「ブラケット(コード生成,quotation)」と
「エスケープ(コード合成,anti-quotation)」を用いるのに対して、
コードコンビネータ方式では、
各演算子に対して、「コード生成版の演算子(コードコンビネータ)」を用意してコード生成器を記述する。
たとえば、加算$e_1+e_2$に対して、
コードコンビネータ版は$e_1 \cPlus e_2$というように、
演算子名に下線をつけてあらわす。

本章では、例に基づいてコード生成器とlet挿入について説明する。
対象言語の構文・意味論などの形式的体系の説明は後に行う．

\subsection{コードコンビネータ方式のプログラム例}

まず、(完成した)コードは、$\code{3}$や$\code{3+5}$のようにブラケットで囲んで表す。
次のコードは、これらを生成するプログラムである。
\begin{align*}
(\cint~3)   & \too \code{3} \\
(\cint~3)~ \cPlus~ (\cint~5) & \too \code{3 + 5}
\end{align*}
$\cint$ は整数を整数のコードに変換し、
$\cPlus$は、整数のコード2つをもらって、それらの加算をおこなうコードを
生成するコードコンビネータである。
なお、$\too$は0ステップ以上の簡約を表す。

$\cLet$はlet式のコードを生成する。
\begin{align*}
\cLet~ x = (\cint~3)~ \cIn~ x~ \cPlus~ (\cint~7)
  & \too \code{\Let~ x = 3~ \In~ x + 7} 
\end{align*}
$\Let$はラムダ抽象と適用によりマクロ定義される。すなわち、
$\letin{x}{e_1}{e_2} = (\fun{x}{e_2})e_1$である。
同様に、$\cLet$は、コードコンビネータとしてのラムダ抽象と適用によりマ
クロ定義され、上記の式は、以下の式と同じである。
\begin{align*}
& (\cfun{x}{~x~ \cPlus~ (\cint~7)~}) \cat (\cint~3)  \\
& \too \code{\Let~ x = 3~ \In~ x + 7} 
\end{align*}

本研究の対象言語は、MetaML や MetaOCaml と同様、静的束縛の言語であり、
以下の例では、束縛変数の名前が正しく付け換えられる。
\begin{align*}
\cfun{y}{\Let~ x = y~ \In~ \cfun{y}{~x~ \cPlus~ y}{}}{} 
& \too \code{\fun{y}{\fun{y'}{y~ +~ y'}}}
\end{align*}
この例では、2つのラムダ抽象が$y$という変数をもっているが、これらは異な
る束縛変数であるので、計算の過程で衝突が置きるときは、名前換えが発生する。

\subsection{コード生成におけるlet挿入}

以下で，我々の言語体系におけるshift0/reset0 による多段階let挿入の例を掲載する．

\begin{align*}
    e &= \red{\Resetz} ~~\cLet~x_1=\csp{3}~\cIn \\
      &\phantom{=}~~ \blue{\Resetz} ~~\cLet~x_2=\csp{5}~\cIn \\
      &\phantom{=}~~ \blue{\Shiftz}~\blue{k_2}~\to~ \red{\Shiftz}~\red{k_1}~\to~ \magenta{\cLet~y=t~\cIn} \\
      &\phantom{=}~~ \cThrow~\red{k_1}~(\cThrow~\blue{k_2}~(x_1~\cPlus~x_2~\cPlus~y))
\end{align*}
とする．

$e$ を計算すると，
$\blue{\Resetz}$によって，切り取られた継続 $\cLet~x_2=\csp{5}~\cIn$ が，
$\blue{\Shiftz}$ によって，$\blue{k_2}$へと捕獲され，
次に，
$\red{\Resetz}$によって，切り取られた継続 $\cLet~x_2=\csp{3}~\cIn$ が，
$\red{\Shiftz}$ によって，$\red{k_1}$へと捕獲される．

わかりやすいところまで計算を進めると以下のようになり，
\begin{align*}
  e & \too \magenta{\cLet~y=t~\cIn} \\
    & \phantom{\too}~~ \cThrow~\red{k_1}~(\cThrow~\blue{k_2}~(x_1~\cPlus~x_2~\cPlus~y))
\end{align*}

$\magenta{\cLet~y=t~\cIn}$ がトップに挿入されたことが分かる．
$\cThrow$ は，切り取られた継続を引数に適用するための演算子である．
つまり，
\begin{align*}
  e & \too \magenta{\cLet~y=t~\cIn} \\
    & \cLet~x_1=\csp{3}~\cIn \\
    & \cLet~x_2=\csp{5}~\cIn \\
    & (x_1~\cPlus~x_2~\cPlus~y)
\end{align*}

となり，$\magenta{\cLet~y=t~\cIn}$ が 二重の $\cLet$を飛び越えて，挿入された事が分かる．
これが多段階 let 挿入である．

また， 項 $t$ の種類によっては，型が付いていてほしくない場合と付いて欲しい場合とがある．
例えば，$t$ が $\code{7}$ のときは，型がつき，
$t$ が $x_1$ や $x_2$ のとき型が付かないようにしたい．
つまり，この例においては，項 $t$ の種類によって，安全なコードか，安全でないコードかが変わるので，それを型で判断したい．このような型システムを構築することを考える．

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
