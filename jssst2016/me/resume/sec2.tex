% section 2

\section{コード生成とlet挿入}

コード生成、すなわち、プログラムによるプログラム(コード)の生成の手法は、
対象領域に関する知識、実行環境、利用可能な計算機リソースなどのパラメー
タに特化した(実行性能の高い)プログラムを生成する目的で広く利用されている。
生成されるコードを文字列として表現する素朴なコード生成法では、
構文エラーなどのエラーを含むコードを生成してしまう危険があり、さらに、
生成されたコードのディバッグが非常に困難であるという問題がある。

これらの問題を解決するため、
コード生成器(コード生成をするプログラム)を記述するためのプログラム言語
の研究が行わており、特に静的な型システムのサポートを持つ言語として、
MetaOCaml, Template Haskell, Scala LMSなどがある。

本研究は、
MetaOCaml などの値呼び関数型言語に基づいたコード生成言語を対象としているが、
言語のプレゼンテーションでは、先行研究にならい
コードコンビネータ(Code Combinator)方式を使う。MetaML/MetaOCamlなどにおける擬似引用
(Quasi-quotation)方式は、コード生成に関する言語要素として
「ブラケット(コード生成,quotation)」と
「エスケープ(コード合成,anti-quotation)」を用いるのに対して、
コードコンビネータ方式では、
各演算子に対して、「コード生成版の演算子(コードコンビネータ)」を用意してコード生成器を記述する。
たとえば、加算$e_1+e_2$に対して、
コードコンビネータ版は$e_1 \cPlus e_2$というように、
演算子名に下線をつけてあらわす。

本章では、例に基づいてコード生成器とlet挿入について説明する。
対象言語の構文・意味論などの形式的体系の説明は後に行う．

\subsection{コードコンビネータ方式のプログラム例}

まず、(完成した)コードは、$\code{3}$や$\code{3+5}$のようにブラケットで囲んで表す。
次のコードは、これらを生成するプログラムである。
\begin{align*}
(\cint~3)   & \too \code{3} \\
(\cint~3)~ \cPlus~ (\cint~5) & \too \code{3 + 5}
\end{align*}
$\cint$ は整数を整数のコードに変換し、
$\cPlus$は、整数のコード2つをもらって、それらの加算をおこなうコードを
生成するコードコンビネータである。
なお、$\too$は0ステップ以上の簡約を表す。

$\cfun{x}{e}$と$\cap$ はそれぞれラムダ抽象と関数適用のコードを生成する。
\begin{align*}
\cfun{x}{x \cPlus (\cint~3)}   & \too \code{\fun{x}{x+3}} \\
(\cfun{x}{x \cPlus (\cint~3)}) \cat (\cint~5) & \too 
\code{(\fun{u}{u+3})~5}
\end{align*}
ラムダ抽象のコードコンビネータにおいて、$x$は「(コードレベルの)変数」その
ものを表すのではなく、「変数のコード」をあらわす。
上記の例の計算過程で、$x$は
$\code{u}$(ここで$u$は新たに作成されたコードレベルの変数)に簡約され、計算が進む。

$\cLet$はlet式のコードを生成する。
\begin{align*}
& \clet{x}{(\cint~3)}{x~ \cPlus~ (\cint~7)} \\
  & \too \code{\Let~ x = 3~ \In~ x + 7} 
\end{align*}
実は、$\cLet$は、コードコンビネータとしてのラムダ抽象と適用によりマ
クロ定義され、上記の式は、以下の式と同じである。
\begin{align*}
& (\cfun{x}{~x~ \cPlus~ (\cint~7)~}) \cat (\cint~3)  \\
& \too \code{\Let~ x = 3~ \In~ x + 7} 
\end{align*}

本研究の対象言語は、MetaML や MetaOCaml と同様、静的束縛の言語であり、
以下の例では、束縛変数の名前が正しく付け換えられる。
\begin{align*}
\cfun{y}{\Let~ x = y~ \In~ \cfun{y}{~x~ \cPlus~ y}{}}{} 
& \too \code{\fun{y}{\fun{y'}{y~ +~ y'}}}
\end{align*}
この例では、2つのラムダ抽象が$y$という変数をもっているが、これらは異な
る束縛変数であるので、計算の過程で衝突が起きるときは名前換えが発生する。

\subsection{コード生成におけるlet挿入}

$\cFor$はfor式を生成するコードコンビネータである。
ここで、(コードレベルの)配列$A$の第$n$要素に対する代入を
$\aryset{A}{n}{e}$と表し、
$\caryset{a}{e_1}{e_2}$は対応するコードコンビネータであると仮定する。
また、$A$は適宜$n$次元のものを考えることにする。
\begin{align*}
& \cforin{x=(\cint~3)}{(\cint~7)} \\
& \qquad \caryset{\code{A}}{x}{(\cint~0)} \\
& \too \code{\forin{i=3}{7}~\aryset{A}{i}{0}}
\end{align*}
$\cFor$を入れ子にすると、入れ子のfor式が生成できる。
\begin{align*}
& \cforin{x=(\cint~3)}{(\cint~7)} \\
& \cforin{y=(\cint~1)}{(\cint~9)} \\
& \qquad \caryset{\code{A}}{(x,y)}{(\cint~0)} \\
& \too \codebegin \forin{i=3}{7} \\
& \phantom{\too \codebegin} \forin{j=1}{9} \\
& \phantom{\too \codebegin} ~~\aryset{A}{i,j}{0} \codeend
\end{align*}

この二重ループの中で、複雑な計算をするループ不変式があったとする。たと
えば、配列の初期値として$0$でなく、(何らかの複雑な)計算結果を代入する
が、その計算にはループ変数$i,j$を使わない場合を考える。
それを$e$とすると、
\begin{align*}
& \codebegin \forin{i=3}{7} \\
& \phantom{\codebegin} \forin{j=1}{9} \\
& \phantom{\codebegin} ~~\aryset{A}{i,j}{e} \codeend
\end{align*}
というコードの代わりに
\begin{align*}
& \codebegin \Let~z=e~\In \\
& \phantom{\codebegin \Let} \forin{i=3}{7} \\
& \phantom{\codebegin \Let} \forin{j=1}{9} \\
& \phantom{\codebegin \Let} ~~\aryset{A}{i,j}{z} \codeend
\end{align*}
というコードを生成した方がよい。

このように、生成するコードの上部(よりトップレベルに近い方)にlet式を挿
入することができれば、早い段階で値を計算できたり、また、同一の部分式が
ある場合は計算結果を再利用できたり、という利点がある。

なお、この変形・最適化は、コードを生成してから行なうのでよければ技術的
に難しいものではない。しかし、
コード生成においては、生成されるコード量の爆発が問題になることが多く、
無駄なコードはできるだけ早い段階で除去したい、すなわち、
コードを生成してから最適化するのではなく生成段階でコードを変形・最適化したいという
強い要求がある。

そこで、コード生成器にlet挿入を組み込むことが考えられる。
let挿入は部分計算(partial evaluation)で研究されてきたものであり、
コントロールオペレータを適切に用いることで実現できることが知られている。
本研究では、shift0/reset0 というコントロールオペレータを用いて上記のlet
挿入を実現する。(従来用いられてきたshift/reset でなく shift0/reset0を
用いる理由は後述する。)

\begin{align*}
    e &= \red{\Resetz} ~~\cLet~x_1=\csp{3}~\cIn \\
      &\phantom{=}~~ \blue{\Resetz} ~~\cLet~x_2=\csp{5}~\cIn \\
      &\phantom{=}~~ \blue{\Shiftz}~\blue{k_2}~\to~ \red{\Shiftz}~\red{k_1}~\to~ \magenta{\cLet~y=t~\cIn} \\
      &\phantom{=}~~ \cThrow~\red{k_1}~(\cThrow~\blue{k_2}~(x_1~\cPlus~x_2~\cPlus~y))
\end{align*}
とする．

$e$ を計算すると，
$\blue{\Resetz}$によって，切り取られた継続 $\cLet~x_2=\csp{5}~\cIn$ が，
以下で，我々の言語体系におけるshift0/reset0 による多段階let挿入の例を掲載する．

\begin{align*}
    e &= \red{\Resetz} ~~\cLet~x_1=\csp{3}~\cIn \\
      &\phantom{=}~~ \blue{\Resetz} ~~\cLet~x_2=\csp{5}~\cIn \\
      &\phantom{=}~~ \blue{\Shiftz}~\blue{k_2}~\to~ \red{\Shiftz}~\red{k_1}~\to~ \magenta{\cLet~y=t~\cIn} \\
      &\phantom{=}~~ \cThrow~\red{k_1}~(\cThrow~\blue{k_2}~(x_1~\cPlus~x_2~\cPlus~y))
\end{align*}
とする．

$e$ を計算すると，
$\blue{\Resetz}$によって，切り取られた継続 $\cLet~x_2=\csp{5}~\cIn$ が，
$\blue{\Shiftz}$ によって，$\blue{k_2}$へと捕獲され，
次に，
$\red{\Resetz}$によって，切り取られた継続 $\cLet~x_2=\csp{3}~\cIn$ が，
$\red{\Shiftz}$ によって，$\red{k_1}$へと捕獲される．

わかりやすいところまで計算を進めると以下のようになり，
\begin{align*}
  e & \too \magenta{\cLet~y=t~\cIn} \\
    & \phantom{\too}~~ \cThrow~\red{k_1}~(\cThrow~\blue{k_2}~(x_1~\cPlus~x_2~\cPlus~y))
\end{align*}

$\magenta{\cLet~y=t~\cIn}$ がトップに挿入されたことが分かる．
$\cThrow$ は，切り取られた継続を引数に適用するための演算子である．
つまり，
\begin{align*}
  e & \too \magenta{\cLet~y=t~\cIn} \\
    & \cLet~x_1=\csp{3}~\cIn \\
    & \cLet~x_2=\csp{5}~\cIn \\
    & (x_1~\cPlus~x_2~\cPlus~y)
\end{align*}

となり，$\magenta{\cLet~y=t~\cIn}$ が 二重の $\cLet$を飛び越えて，挿入された事が分かる．
これが多段階 let 挿入である．

また， 項 $t$ の種類によっては，型が付いていてほしくない場合と付いて欲しい場合とがある．
例えば，$t$ が $\code{7}$ のときは，型がつき，
$t$ が $x_1$ や $x_2$ のとき型が付かないようにしたい．
つまり，この例においては，項 $t$ の種類によって，安全なコードか，安全でないコードかが変わるので，それを型で判断したい．このような型システムを構築することを考える．

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
