# jssst 原稿


# power関数のコード生成器

前提として，x^n の n に特化したコードを生成したいとする．

* x のところはあとにとっておくつまり，計算をしない（動的 -- 後に残す計算）ところにアンダーバーのある演算子（コードコンビネータ）を入れておく
* nに依存したところの計算は事前に計算しておく（静的 -- 今できる計算）

# shift0/reset0によるlet挿入 p18
1. このコード生成器にshift0/reset0を入れて cc という計算を２つのfor文を飛び越えて，そこへlet挿入を行うことを考えます．
2. このようにshift0/reset0 を入れることで，ピンク色の `let u = cc in` が `reset0`の位置まで持ち上がり let挿入が可能となります．
shift0 と reset0 は対応関係にあります．
shift0 は reset0からshift0 までの評価文脈を切り取り `k` へ束縛します．
3. このように．緑色で書かれた評価文脈が `k` へと代入されます．２重矢印 `<=` は評価文脈を`k`へ代入するということを表しています． `k` に代入されている評価文脈の後ろの `[]` は評価文脈の穴です．
4. そして，評価を進めると，このように `let u = cc in `が先頭へ挿入されていることが確認できます．`throw k u` というものは 評価文脈を実際に使うということを表していて，評価文脈 `k`の穴へ `u` が入ります．
5. そして，以下のように２つのfor文を飛び越えて let が挿入されるようなコードが生成されます．


# shift0/reset0による多段階let挿入 p19
1. このコード生成器は多段階let挿入を行う例です．このコード生成器は
2. `let u = cc1 in` を `for x ...`  と `for y ...` の間へ挿入し，
   `let w = cc2 in` を２つのfor文を飛び越えて挿入するコードを生成します．

ここで見てほしいのは，`set b...` の行です．２つの shift0 をネストさせることで，直近の青色のreset0 でなく，２つ先の 赤色の reset0 で限定される継続を赤色の shift0 で 赤色の`k2`に束縛することができ，多段階のlet挿入を実現しています．
このようにshift0をネストさせることで入れ子になった reset0を複数飛び越えてlet挿入ができるので，多段階let挿入が可能となっています．
しかし，このようなことはshift/reset ではできません．この点がshift0/reset0 を本研究で採用した理由です．


# コード生成前・後でスコープの包含関係が逆転 p26
1. 上のコード生成器から下のコードが生成されます．
このコード生成器はピンク色の `let u = cc in` という式を `for x ...` と `for y ...` の間に挿入するコードを生成します
ここで着目していただきたいのは，shift0/reset0を使うことで，`gamma1` と `gamma2` の包含関係がコード生成器と生成されたコードとで逆転している点です．

2. 右側に書いた環境識別子`gamma`の関係は，スコープの包含関係を表しています．
上のコード生成器の場合は，`gamma0` より `gamma1`が大きく，`gamma1` より `gamma2` が大きく．．．ということを表しています．そして，プログラムのネストがふかくなるに連れて，使えるコード変数が増えていくということを表しています．コード変数というのは簡単に言うとコードコンビネータで使われている変数のことです．
この順序関係を見ると，スコープが逆転しているということが見てわかると思います．
次で，各`gamma`のスコープで使えるコード変数について見ていきます．

# コード生成前・後でスコープの包含関係が逆転 p27
この表は各`gamma` で使えると思われるコード変数との対応を表した表です．
ここで見ていただきたいのは，青色の部分です．
コード生成器と生成されたコードの `gamma1` `gamma2` はスコープの包含関係が逆転しているので，
それら２つの間に順序関係はありません．
Sudoらの使った環境識別子の定義を素朴に使うと，このようなことから型が合いません

# 環境識別子(EC)を利用したスコープ表現 p23
## メモ
ここはしっかりと
型環境 `Gamma` のところ
* 順序の記号
* 型について 例えば `<int>` は int code 型であるということを言葉で説明する．
  `x :<int>^gamma1`は `x` は int code 型であり `gamma1` というスコープで使えるものであるという説明を行う．


固有変数条件

```
judgement1
---------- (gamma1 *)
judgement2
```
judgement1 で 固有変数として gamma1 を導入し，
judgement2 以下で gamma1 は出てこないという条件

なので，型付けを下からしていくにしたがって，段々と使えるコード変数が増えていくイメージ
プログラム（バインダー）のネストが深くなるにしたがって，段々と使えるコード変数が増えていくイメージ

# コード生成 + shift0/reset0 の型システム p30
* (例えばreset0の型付け規則のジャッジメントのお尻に付いている セミコロンより右側はアンサータイプを表しています．他の規則も同様です．)

* shift0 の型付け規則を見てください．
  棒線の下のジャッジメントの `gamma1` と上のジャッジメントの `gamma0` とでスコープが異なっているのは，shift0 によって切り取られる継続は reset0 によって限定された継続でした．なので，`e` はreset0の`gamma0`のスコープであるので，それを表しています．

* throw の型付け規則を見てください．
throw のところで初めて`gamma2`というスコープが表れます．この `gamma2`と shift0 のところの `gamma1`を合わせたコード変数が`v`で使えるということを `gamma1`と `gamma2`のユニオンで表しています．

# 型付けの例(1) p31
1. 上の コード生成器 `e` を御覧ください．
   この生成器は `let u = ...` を `for x ...` の上へ挿入するコードを生成します．
   下の図はこの生成器の型付け図です．
   緑のボックスの型は最終的に `gamma0`レベルのものでなければ型が 生成器`e` には型が付かない
   `gamma0`は何を表しているかというと，コード生成器 `e` 全体のスコープを表しています．
この緑のボックスに入れるもので型がつく場合と付かない場合を見ていきます．

2. `int_ 3` の場合は，型が付きます．
なぜなら，どのスコープでも `int_ 3` は型が付くので，もちろん `gamma0` でも型が付きます

3. `x +_ (int_ 3)` の場合は，型が付きません．
なぜなら， 型環境`Gamma a` に着目して下さい． 順序関係として，`gamma1`は `gamma0` を含みます．
そして， `x` は `gamma 1` レベルのものなので，それより小さい `gamma0` レベルでは型が付かず，`x +_ (int_ 3)` は `gamma 0` レベルでは型が付かないことがわかります．

なぜ `gamma1` より `gamma0` のほうが大きいということが言えるかというと，
* `gamma1` は固有変数として新たに導入されているので，`gamma0` と `gamma1` は等しいとすると，固有変数条件を満たされない．なので， `gamma0` と `gamma1` は等しくないので，`gamma0`より `gamma1` は大きいので， `x + int 3` は `gamma0`レベルでは型が付かないということが言えます．


# 型付けの例(2)
このコード生成器は `let u = box in` が２つの for 文を飛び越えて 挿入されるコードを生成します．
shift0 を２つネストさせることで 内側からが数えて２つ目の 赤色のreset0 のところへ let が挿入されるので，多段階のlet挿入が実現できています．

そして，この緑色のボックスに入るものによって`e'`に型が付く付かないということを説明していきます．
緑色のボックスには `gamma0` レベルの型のものが入れば型が付きます．
`gamma0`とは `e'`というコード生成器全体のスコープを表しています．
赤色のreset0 まで let が挿入されるので，緑色のボックスは `gamma0`レベルの時に型が付いてほしいわけです．なので， `x` や `y` に依存した式がここに入ってしまうと，ループ不変式でないので，型が付かないということになります．
