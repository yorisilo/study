# jssst 原稿


# power関数のコード生成器

この gen_power は、
先ほどの power 関数を、
n について特化したコードを生成するコード生成器です。
n は静的な変数、つまり、コード生成時に消費する変数となります。
一方、x は動的な変数、つまり、コードに残る変数で、それを「コード変数」と呼びます。

3行目のかけ算は、x に依存する計算なのでコードの中にそのまま残ります。
我々の言語では、このような演算子を、下線を引いてあらわします。
(「下線を引いて」としゃべるときに、3行目を指すこと)

下線がつかない変数や演算子はコード生成時に消費され、
このように、 (ここでクリックして、xの5乗の生成コードを表示する。)
再帰やifを使わないxの5乗を計算するコードが生成されます。

# shift0/reset0によるlet挿入 p18

1. _(スライドが最初の状態 -- クリックする前)_

   素朴なコード生成器において、このcc を２つのforループの上に移動するlet挿入を行
うよう、変形します。

2. _(1回クリックして reset0-shift0 等を表示する)_

   そのため、このようにプログラムを変形します。
   青字の shift0 と reset0 がコントロールオペレータです。
   shift0 は reset0からshift0 までの評価文脈を切り取り `k` に束縛します．

3. _(1回クリックして 評価文脈が緑色になり、k への束縛が表示される)_

   この緑になった部分が、shift0 によって切り取られる評価文脈で `k` に束縛されます．
   k のあとの２重矢印 `<=` は継続変数k への特殊な代入で、最後のだいかっこ[]
   で書かれたものは、評価文脈の穴、ホールを表します。

   ここで、計算をワンステップすすめると、評価文脈が削除されます。

4. _(1回クリックすると、評価文脈が削除される)_

   さらに計算をすすめて、
   `throw k u` を評価すると、緑色の評価文脈が k の部分に代入されます。
   この際、評価文脈の穴に、throwの引数の u が埋めこまれます。
   最終的に、
   一番下のコードが生成され、
   let挿入が実現できたことが確認できます．

# shift0/reset0による多段階let挿入 p19
これは、先ほどの1段階let挿入の例を、2段階に拡張したものです。
赤色のreset0, shift0, throwは対応し、青色のものも同様です。

このコード生成器は
`let u = cc1 in` を2つのfor式の間に挿入し、
`let w = cc2 in` を一番上に挿入するものです。
2つのletを異なる場所に移動するため、reset0 が2つになり、
2つ目の let w = cc2 の方は、青色のreset0を飛び越えて、赤字のreset0のと
ころまで移動することになります。

ここで、`set b...` の部分に注目してください。
このように、２つの shift0 をネストさせることで，直近の青色のreset0まで
の継続と、赤色の reset0 までの継続を切り取ります。
それをlet w = cc2の内側で、
ネストしたthrow で利用することにより、let w = cc2 が一番上まで移動します。

このようにコントロールオペレータをネストさせることで、
reset0を飛び越えたlet挿入ができ，多段階let挿入が実現できます。
これは、広く利用されているshift/reset では実現できないため、
本研究では、shift0/reset0 を採用しました。

# コード生成前・後でスコープの包含関係が逆転 p26

これは、コード生成器と生成コードの、コード変数のスコープを四角い枠で示したものです。

上のコード生成器は、ピンク色
(<-- えっ、これは私には紫、あるいは、赤紫に見えますが。。。
それとは別に、一般的にいって「ピンク」という言葉は、わりと嫌らしい意味につかわれるこ
とが多いので、ちゃんとした研究論文や研究発表では、なるべく使わない方がいいです。
もし、この色がピンク色にみえるとしても、「むらさき 」とか「あか」とか
言ってしまいましょう。なんと呼んだっていいですよ。)

の `let u = cc in` という式を2つのfor式の間に挿入するものです。
shift0 の実行により letが挿入され、
スコープ `gamma1` と スコープ`gamma2` の位置関係が逆転していることがわかります。

(ここでクリックする)

2. 図の右側に、スコープの包含関係を書きました。
小さなスコープをもつgammaは、使えるコード変数が「より多い」ので、順
序関係としては「だいなりいこーる」で表されます。
たとえば、gamma0スコープ は gamma1スコープ を包含するので、gamma1 だいなりいこーる gamma0
と表示しています。

コード生成の前後で gamma1 と gamma2の順序が逆転していることがわかります。

# コード生成前・後でスコープの包含関係が逆転 p27

(えーと、私としては 27ページは削除して、26ページだけをつかって「問題点」
を説明した方がいいとおもっています。月曜日にそう言ったつもりでしたが、
私の記憶違いかもしれません。その場合はすいません。ともかく、27ページを
削除して 26ページだけで須藤らの問題点を指定する場合は、以下の説明をするとよいで
しょう。「もし、式 cc がコード変数y を含んでいると、コード生成後は
y に対応する変数yプライム を含んでしまうことになり、
図からわかるように、変数スコープのエラーとなってしまいます。」)

! 27ページ自体を削除
! この表は各`gamma` で使えると思われるコード変数との対応を表した表です．
! ここで見ていただきたいのは，青色の部分です．
! コード生成器と生成されたコードの `gamma1` `gamma2` はスコープの包含関係が逆転しているので，
! それら２つの間に順序関係はありません．
! Sudoらの使った環境識別子の定義を素朴に使うと，このようなことから型が合いません

# 環境識別子(EC)を利用したスコープ表現 p23

先ほどの例で、
gamma2 だいなりいこーる gamma1のとき、コード変数xとyの型付けがどうなる
かを説明します。

x がgamma1スコープの int型のコードをあらわすコード変数のとき、このように
x ころん ぶらけっと int gamma1 と表します。
「ぶらけっと int」はMetaOCamlの「int code」型に相当します。
同様に yをgamm2スコープの変数としてこのように表します。

これらを含む型環境を大文字のgammaとするとき、
この型環境のもとで、x はgamma1スコープの変数ですが、さらに、gamma2 が
gamma1より大きいので、gamma2スコープの変数ともなります。
一方、y はgamma2スコープの変数ですが、gamma1 はgamma2より大きくないので、
y が gamma1スコープではありません。

x+y の形のコード生成器は、gamma1スコープはもたず、gamma2スコープをもつことがわかります。

この「y はgamma1スコープのコード変数としては使えない」という条件を、
Sudoらは、自然演繹(えんえき)の固有変数条件を用いて表現しました。
この型付け規則(といって、p.23一番下の型付け規則を指す)で、
gamma2 が固有変数であり、規則の結論にgamma2が出現してはいけないこと、
いいかえれば、下から上に見たとき、gamma2 がfreshな変数であるという条件となります。

# コード生成 + shift0/reset0 の型システム p29

本研究で構築した型システムの一部の規則を紹介します。

* 我々の型システムのジャッジメントは、この形(といって、一番上のreset0の横棒の
上の表現を指す) をとります。これは、large gamma のもとで、式 e が、
この型をもち、そのcontrol effect がこのような型の列であることを表します。
control effectは answer type の列ですが、詳細は省略します。

3つのコントロールオペレータ型付け規則はこの通りです。

特に注目していただきたいのは、shift0規則の赤い文字の環境識別子です。
上の gamma0は、shift0を囲むreset0 を含むスコープに対応し、
下のgamma1は、shift0式のスコープに対応します。
ここでgamma0 の方が、gamma1 より我々の順序では小さい、つまり、スコープとしては広い
ものであるのに、式e はその広いスコープの環境識別子をもつという点が、ここでのポイントです。
subterm の方が superterm より広いスコープを持つというのは
通常の term ではあり得ないことであり、
コントロールオペレータに特徴的な規則となっています。

次に、具体的な型付け例を説明します。

# 型付けの例(1) p30


この項 `e`は、`let u` を `for` の上へ移動したコードを生成するコード生
成器です。
緑のボックスにはいる項によって、eが生成するコードは安全だったり危険だったりします。

eの型付けはこのようになります。

(ここで、一番下の2行である Gamma a と Gamma b を指す)
gamma0 はこの式e 全体を含むスコープ、gamma1 は forのループ変数である x が宣
言されたスコープ、gamma2 は let挿入される u が宣言されたスコープとします。
本研究の型システムのポイントは、shift kのあとの項、つまり、
この緑のボックス周辺のスコープ変数が gamma1 でなく gamma0 であることです。

(クリックする)
緑のボックスが `int_ 3` のようにコード変数を使わない式のとき、
これはどんなスコープでも型がつくので、`gamma0` でも型が付き、式e全体に
型がつきます。

(クリックする)
一方、緑のボックスが `x +_ (int_ 3)` の場合は，型がつきません。
なぜなら， 型環境`Gamma a` にあるように、x はgamma1スコープの変数であり、
それより小さなgamma0スコープには含まれないので、
gamma0 でこの式が型がつかないからです。

!! 以下の説明は、本体の説明では言わない。質問があったときの答えることにしたはず。
! なぜ `gamma1` より `gamma0` のほうが大きいということが言えるかというと，
! * `gamma1` は固有変数として新たに導入されているので，`gamma0` と
! `gamma1` は等しいとすると，固有変数条件を満たされない．なので，
! `gamma0` と `gamma1` は等しくないので，`gamma0`より `gamma1` は大き
! いので， `x + int 3` は `gamma0`レベルでは型が付かないということが言
! えます．

# 型付けの例(2) p31
次に、多段階let挿入の例を見てみます。
この項e' は、let u を一番外側の赤いreset0 の位置に挿入します。

詳細は省略しますが、
この緑色のボックスは、項の中の深い部分にありますが、
我々の型システムでは、一番外側のスコープをあらわすgamma0のスコープを持
ちます。これは先ほど説明したshift0規則から導けます。

このため、緑色のボックスには コード変数 `x` や `y` に依存した式がはいっ
ていしまうと型がつかないことになり、二重forループの外でも型がつく式を
入れた場合のみ型がつくことがわかります。

このように、本研究の型システムは安全、あるいは危険な項を正しく判別できます。
