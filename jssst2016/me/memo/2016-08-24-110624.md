Wed Aug 24 11:06:33 2016

# 発表
23-4分を目標にして作る


# ストーリー
* コード生成におけるlet 挿入の説明を例を使って説明
* 例を洗練させる？
* 須藤さんのref-cell でできない例 かつ 大石研究でできる例のチョイス -> 今の例でおｋ？ forのやつ こっちは説明を詳細に

1. 問題 7分
コード生成におけるlet 挿入の説明を例を使って説明
多段階
危険な例

1. どう 11分
   1. s0/r0 の説明 時間かかるところ (プログラムの例) 2,3分
   s/r 比較 多段階じゃないから
   multi prompt s/r 比較
   multi prompt s/r でできない理由 単に飛んで行くことはできるが，型を付けるのがおそらくうまくいかない 質問用に用意？ スライドのしたの方に
   1. EC taha 概要
      REC sudo
      <x+3> : <int>^{x:int} とせずに<x+3> : <int>^γ とする理由はなんだっけ？ 自由変数自体を型の肩につけずに，その名前を新たに作ってあげてそれを付ける理由は？
      * 自由変数をつけてしまうとある種の依存型になってしまうので，型推論が複雑になる．
      * term レベル と型レベルは分けるほうが型システムを作りたい
      RECJ oishi 8分
      * ECの洗練化のスライド
   1. join

1. できること 5分
   1. 型付けの例
   いくつか  t = <7> だったらおｋとか
   一枚でさらっと．sudo のif-insertion はできるとか書いておくと良い
   (sudo とかいままでの比較)

   1. Discussion
   * SRの証明 まだ完成してない
   * 型推論 やりたい
   * 言語の拡張
   * (CSPはない cspとは現在ステージで使える関数をコード生成後にも利用するやつ)
   * ocamlのexecption はある程度
   * レベルは２個
   * runを入れるのは簡単？

```
a[i][j] = b[j] + s0s0 let y = t in k1 k2 y
```

# 既存研究
* kks 2009
fib

* skk 2014
* aplas 2016
if-insertion

* ok 2016
let-insertion forのやつ

* 思いつかなければ，過去の例を掲載して，
全部できるようになったということを伝える． <- 全体の話のあとでもいいかも，時間配分を見て決める

* s/r で 破壊的変数が表せるということを簡単に説明もしておく
(reset 0 ( let = ... in \x.r )) v
...のところで put とか get とかを使いたい
... は v を書き換えることをする

put v' = sk.\x k v' v'
get v = sk. \x k x x

* 単なる s/r では 一番内側の ref しか使えない

* 階層的になってる破壊的代入も実現できる

* 一枚のスライドで ref-cell ができるようになったことをいう
ref-cell とはいわずに 破壊的変数をいう
須藤らの破壊的変数はできるということをいう．

グローバルのやつは別に言わなくて良いかも

# 何を実現するか
何がlet-insertion で何が難しいのかを伝える

多段階もやりたい．s/r ではできないのでs0/r0



# これからの大石言語
* 外に出しても良い let 束縛 の位置を自動で知る
* let 束縛 自動で跳んで行きたい

一個上がる操作のことを weekning という
