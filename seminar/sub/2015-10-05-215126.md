# CSセミナーに向けてのミーティング
* Mon Oct  5 21:51:34 2015

# Article summary
## Subtyping Dlimited Continuations 2011
Danvy と Filinski のshit/resetを一般化した first-class な限定継続の部分型づけをもつ型システムを提案した．

## A Dynamic Interpretation of the CPS Hierarchy 2012
shift0/reset0は，CPSによる階層化を完全に表現できることを示した．

## Axiomatizing Subtyped Delimited Continuations 2013
danvy と flinski のshift/reset を一般化した shift0/reset0 call-by-valueのラムダ計算の直接の等式による公理化を提示した．

# 研究のテーマ
## shift0/reset0を含んだ言語のインタプリタからコンパイラの導出
対象言語の方にshift0/reset0を．
partial evaluation の考え方でインタプリタからコンパイラへ

CPS インタプリタ (term env cont)
pure な lambda term

* DSL のインタプリタからコンパイラへ ほぼ自動で．

* インタプリタからコンパイラ
DSLのインタプリタをコンパイラにする
DSLを作るための

* 任意のDSLに対するインタプリタ，コンパイラ，型システム
任意のはむずかしいから，範囲を決めてやるとか．

DSLを定義するのは良いのだけど，
* パーサー，
* typeチェッカー，
* インタプリタ，
* コンパイラ
を手で作るのは面倒．

それらのためのインフラ作り

* Oleg さんは tagless finall で何でもやるべき派


## ステージング + simplifyした shift0/reset0 の体系 推論規則，型システム，実装．(型システムの健全性を示す)．

shift0/reset0 の型システムは複雑なので，単純に shift0/reset0 をステージングの体系に加えるのでなく，研究の目的にあったサイズに simplifyした shift0/reset0 の体系を考える．

* そのsimplify したshift0/reset0 とstagingの体系を組み合わせる．
  * simplify:例えば，subtyping をとっちゃうかもしれない．

* メタ言語: simplify した shift0/reset0 + ステージング の言語を考える．
* 対象言語: もしかしたら，こっちも shift0/reset0 を考えるかも

let insersion のポイントはたくさんある．
それを shift0/reset0 で表したい．

最大レベルの n を固定しないと，shifti/reseti での階層化はできない．

### keywords
* lambda circle (ステージングのラムダ計算体系) + shift0/reset0 の体系を作る．
* monadic staging
  * メモ化:ステートモナドを利用してステージングをやる
* staging (lambda circle)
* shift0/reset0 (lambda ...)
* shift0/reset0 の型システムはかなり複雑
* コード生成においてはコードを覚えておくことが必要． effectが問題．gibの例(shifting the stage) let insersion


### let insertionの例
```ruby
for i 0..n
  for j 0..m
   <iとjによらない処理>
   end
end
```
->
```ruby
<iとjによらない処理>
for i 0..n
  for j 0..m

   end
end
```

```ruby
for i 0..n
  for j 0..m
   <jにのみに依存する処理>
   end
end
```
->
```ruby
for j 0..m
<jにのみに依存する処理>
  for i 0..n

  end
end
```

### 発表の雛形
* why: なぜshift0/reset0 + ステージング の言語が必要なのかの説明．
  汚いコードを出したいわけでなく，検証可能なコードを出したい．正しさを気にしたい．
* shift0/reset0 について:
  階層を一気に表せる shift0/reset0 は魅力的． 単純なCPS変換があり，pure なラムダ項で表せるのが嬉しい．c/r は表せない．
* staging (lambda circle)について:
* 本研究 s0/r0 + staging  をどうやって足すか
 * 今やってること
 * ...
 * ...


# スライド
---------------------------------------------------------------------
CSセミナー発表 プロット

* 研究の背景(1) 段階的計算

  プログラムによるプログラム(コード)の動的な生成
  「保守性」と「性能」の両立をはかる

    "Abstraction without Guilt"
       ... プログラムの抽象化を、性能低下なしに実現したい

   ==> コード生成 アプローチ (段階的計算)
   power func の 例を用いても説明してもよいかも

   * コード生成プログラム: 高レベルの記述 (高階関数、代数的データ型 etc.)
                      一般的、抽象的なアルゴリズムの記述

   * 生成されたコード:    低レベルの記述 (高性能の実行が可能)
                       特定のハードウエアや特定のパラメータを仮定したコード

* 研究の背景 (2)

   コード生成プログラムの大きな問題は信頼性(正しさ)

     * 構文的、意味的に正しくないプログラムを生成しやすい
     * ディバッグが容易ではない
     * 効率のよいコード生成に必要な計算エフェクト(後述)を
       導入すると、従来理論ではコード生成プログラムの安全性は
       保証されない。


* 研究の目的

   安全で、効率の良いプログラムを生成するコード生成法の確立

   * コード生成に必要な種々の計算エフェクトが、安全に
     正しく使われているかを自動的に検査

   * 計算エフェクトとして、特に、shift0/reset0 によるコントロール抽象
     を用いたコード生成

  研究項目
   1. shift0/reset0 を持つプログラム生成のための体系の構築
        型システムと操作的意味論の構築
        型の健全性の証明
   2. shift0/reset0 を持つプログラム生成のための言語の設計と実装
        抽象機械による実装
        効率のよいコード生成プログラムの例の作成

これ以降のスライドは、以下のものを書く。

==============================
   コード生成の例 (単純なもの、let挿入がいるもの)
   shift0/reset0の例(shift/resetの例と、shift/reset階層の例)
   ここはしっかり論理的に説明できるようにする

==============================


  次に、
   コード生成のための型システム λ○
   shift0/reset0 の型システム (Materzok & Biernacki)

ここにいれる <= 2:44 ごろ

本研究の手法:
   shift0/reset0 の型システムを単純化 (Answertypeモディフィケーションとかをなくすかも)して、λ○と融合

  今後、型システムの設計と健全性の証明、言語の実装 をやる
---------------------------------------------------------------------

## CSセミナーに向けて 2回目のミーティング
1回しっかり説明したスライドを作ってから，simplifyする．っていうやりかた．

# スライドの作り方
直感的に分かるようなものは，絵にする．

アニメーションを使ってわかりやすく．

ストーリーを気にしよう．
やってることがどういう利点で重要なのかを話す．


# ゴール
on going の研究発表
問題そのものが意義があって面白いということをいいたい．


ハイレベルコーディングとは，

保守性 = モジュラリティ 再利用性を含む
性能を得たい

性能を得たいって思うと，保守性を犠牲にする

アブストラクション いろんな事を抽象化したい．
一般的には，アブストラクションを考えると，保守性を犠牲にしてしまう．
人間はハイレベル言語で，
プログラムは，性能の

動かすときは性能の

特に型安全性，スコープの安全性を担保するようなコード生成を行いたい．

コード生成の信頼性を得るためには色々なアプローチがあるが，
なぜ shift0/reset0 なのか

* ドメインエキスパートがやる細かい最適化をしたい．

* 全自動のコンパイラ，部分計算での，

そもそも
型安全性，スコープ安全性を考慮した

type check が終わったら，
by constraction


* 計算エフェクトの例

* shift/reset でなく，階層化 shift/reset または，shift0/reset0 でしか書けない
let インサーションの例
行き先の違うコードが二箇所出てくる例を考える．

* 須藤さんの修論を見る．
if インサーションの例

* gibonatchの例 これは書ききれないので，イメージ図で
shift/resetで gib はかけるが，
2つ組み合わせたgib とかは階層化のやつしか書けない．

* shift0/reset0 では 動的束縛

* マルチプロンプト shift/reset との戦い

ステージングには素直なcps変換は考えられない

shift0/reset0 で嬉しいのはコードの検証がしやすい ．．．かもしれない．
