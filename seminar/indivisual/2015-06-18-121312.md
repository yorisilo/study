# 個人ミーティング

## 6/17の個人ミーティングで話したこと

### エフェクトのある場合のマルチステージ言語の型安全性を保証する
shift/resetが入ったようなシステムの型安全性を保証したい．

現状では例えば，olegのmetaocamlはまだ型安全ではない．
実装はhaskellでolegが完全に実装したものがある．
それがどうしてうまく動くかはまだきちんとした証明はない．
もっとそれをシンプルにしたラムダ計算ベースのシステムの型システムで，
スコープ安全性とか色々な安全性が満たされるということを証明したい．

須藤さんはリファレンスのある体系ではある程度仕事をした．
実装はせずに紙の上で終わってしまった．
それを実装するのは，多分4年生が行う．

リファレンスセルよりももう少し広い範囲で
例えば，shift/resetのような本当に書きたいものを書ける拡張をしたい．

### ステージ化したプログラムが元のプログラムと等価であることをcoqで検証する
ただのプログラムをブラケットとかエスケープを入れてプログラム生成器にして，
特化して速くするのだけど，単にブラケットエスケープを入れるだけだと，部分評価と変わらなくて，自動的にできてしまう．
ステージングと我々が言っているのはそこが本命ではなくて，
特定のドメインについては人間が手で色々最適化を行って速いコードにしたい．なぜなら，機械よりも人間が特定のドメインについては最適化をうまくできるから．

ドメインごとの微妙な最適化（例えば，扱ってる行列が対称行列だとしたら，上三角行列のみを扱ってあとはコピーすれば良い）を正しいという検証する手段はあまりない．

そうなると，プログラムごとに検証式が変わってしまう．
しかし例えば，任意のブロッキングが正しいことの証明はやろうと思えばできるはず，
しかし，プログラム生成器にかけるようないろんなプログラムの私がたまたま思いついた最適化手法が正しいってことは私しか証明できない．
最低限したいことは，あなたの最適化が正しいということを証明するには，この式を証明すれば良いよという論理式を生成するということはできる．

#### proof obligation （あとはこれだけ証明したら正しいことが言えるみたいな論理式を生成するとかいう意味）
もはやプログラム生成器ではなく，あるプログラムが正しいということを証明するためのそれの論理式の生成器．
その論理式は場合によっては，海野先生のような自動証明を行うものへ投げたり，人間がcoqで一から証明を行う．

任意の2つのプログラムを持ってきてそれらが等価であるということの証明はできない．
もとのプログラムからある規則正しい変換を行った後のプログラムが等価であるということの証明はできるはず．
それらでカバーできない場当たり的なプログラム変換を行った場合は，人間が等価であるかどうかを証明する．

#### test case generation
コードから論理式の生成だけでなく，コードからテストコードも生成したい．

#### coqのtactic言語の話
coqの方は完全にタイプが付いているのに，
tacticはタイプが付いていない．

tacticはどんなにバカをやっても，coqは壊れない．coqは絶対に正しい証明しかパスしないから．
とはいっても，tacticの設計はさすがにひどいので，どうにかしたい．
新しいtactic言語を作ろうみたいな話．
Ltac
Mtac

### コントロールオペレーター
小堀さんのやつとか．

### 鈴木さんの研究
SQLのやつ

---
## 大石が興味のあること
### 部分評価器を MetaOCaml によって作成する．


###  proof obligation （あとはこれだけ証明したら正しいことが言えるみたいな論理式を生成するとかいう意味）
特定のドメインについては人間が手で色々最適化を行って速いコードにしたい．なぜなら，機械よりも人間が特定のドメインについては最適化をうまくできるから．

ドメインごとの微妙な最適化を正しいという検証する手段はあまりない．
<!-- （例えば，扱ってる行列が対称行列だとしたら，上三角行列のみを扱ってあとはコピーすれば良い） -->

すると，場当たり的に最適化を施したプログラムごとに検証式が変わってしまう．
<!-- しかし例えば，任意のブロッキングが正しいことの証明はやろうと思えばできるはず， -->

しかし，ある最適化が正しいということを証明するには，この式を証明すれば良いよという論理式を生成するということはできる．

<!-- プログラムから論理式を生成する． -->
<!-- ドメインを決める必要がある． -->
<!-- インタプリタを速くする． -->

#### その特定のドメインを何にするか
数値計算分野は嫌だ．
コンパイラとかに用いる個々の最適化の正当性の証明のために論理式を生成したい．


###  call-by-hoge のラムダ計算の評価器に対して，プログラム変換を施し，ある機械を導出する．その導出した機械をコンパイラと仮想機械へ分割する．

Olivier Danvyらの手法であるfunctional correspondence（プログラム変換前後におけるプログラムの観測等価性が保証されているプログラム変換のみを用いて，評価器からある抽象機械を導出するという方法）を用いて，評価器からその評価器と等価な機械を導出する．

例えば，call-by-push-value の評価器を functional correspondence によって 観測等価な 何らかの機械へ導出する．
<!-- プログラム変換によって，評価器から abstract machine を導出する -->

#### 方法
あるラムダ計算の評価器から観測等価な抽象機械への導出を行う方法を考える．
いくつかのプログラム変換を行い，より低レベルな機械への導出することを目指す．
その導出した機械を，コンパイラと仮想機械に分割する．

用いたプログラム変換が変換前後で等価であるということの証明を行うことで，変換前後でプログラムが等価であるということの正当性を与える．

#### 参考となる論文
[From Interpreter to Compiler and Virtual Machine: A Functional Derivation](http://www.brics.dk/RS/03/14/BRICS-RS-03-14.pdf)


## 直近の大石がやること
[A Gentle Introduction to Multi-stage Programming, Part II](http://www.cs.rice.edu/~taha/publications/journal/gttse07.pdf) を読む．

そして，実装を行ってみる．
