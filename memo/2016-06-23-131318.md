* Mon Jun 27 17:39:22 2016

# shift0 / reset0 の型システム

shift0 は外側にある reset0 に囲まれた継続を取ってきて，k に束縛して 関数e内で使うということをする．なので，そのshift0 での式だけを見ただけでは，kの型がわからない．

また，shift0/reset0 はs/r と違い，スタック上の任意の文脈にアクセスできるので，より多くの文脈の情報が必要となる．

# 須藤さんの型システム
コード生成の体系に local reference を加えたもの

local reference を加えると，scope extrusion が起きてしまうので，
それを型システムで防ぐ．つまり，scope extrusion が起きるような式は型システムで型が付かないようにする．コンパイル時にそのような式は型エラーが出るので，実行時にはそのような式に対して実行することがない．


# 評価文脈

``` ocaml
e ::= v | e1 e2 （式）
v ::= x | λx. e （値）
E ::= E e | v E | [ ] （評価文脈）
E[(λx. e) v] → E[e[v/x]] （簡約規則）
```

`((λf . λx. f x)(λy. y))(λz. z)` のステップ実行を考えてみよう。
この表現全体は関数適用の形なので、評価文脈 `E e` に従って、まずは関数部分 `(λf . λx. f x)(λy. y)` を評価する。
これも関数適用の形なので、再び評価文脈に従って、`λf . λx. f x` を評価する。これは `λ` 抽
象、すなわち値なので、今度は評価文脈 `v E` に従って、引数 `λy. y` を評価する。これも値になった
ので、現在注目している部分`(λf . λx. f x)(λy. y)`が redex となる。

# 継続を扱うための方法
* CPS変換を使う方法
* 評価文脈を使う方法
文脈とは穴を持つプログラムのこと `λx.[]y z` のような項のこと．
評価文脈とは，文脈の特殊なモノであり，その穴がちょうど次に計算する順番になっているモノ．

``` ocaml
term     M, N ::= x | λx.M | M N
value       V ::= x | λx.M
redex       R ::= (λx.M) V
ev. context E ::= [] | E M | V E
```



`M = E[R]`とは，評価文脈の穴`[]`のところに`R`を入れてできる項のこと
例えば，
`M = ((λx. (λy. y) z) w) u`
`E = []u`
`R = ((λx. (λy. y) z) w)`

`M` に対しては，上記の `E` `R` 以外に対してはうまくいかない．
例えば，下の`E'`は `E`の定義と異なるので，ダメ．
`E' = ((λx. (λy. y) z) w) []`
`R' = u`


例外処理など、非局所的な制御を定式化するには「プログラムの残りの計算」を表す継続が使わ
れる。近年、継続を明示的に扱えるようにして、複雑な制御をプログラムの中で記述できるよう
にした言語体系が多く提案されるようになって来た。
継続を議論するための枠組みには、CPS 変換や評価文脈を使った方法がある。CPS 変換は、継 続に対する特殊な枠組を用意することなく継続を表現することができるが、CPS 変換は大域的な 変換であるためプログラムの構造が大きく変化してしまう。一方、評価文脈を使えば、プログラ ムを大きく変換することなく継続についての議論をすることができるが、評価文脈という新しい 概念を導入する必要がある。
項と継続を統一的に扱う理論としては、Filinski が既に 1989 年に対称ラムダ計算 (Symmetric λ-calculus, SLC) を提案している [5]。SLC においては項と継続が完全に対称(双対)な形をし ており、項を扱うのと同じように継続を扱うことができる。言わば評価文脈があらかじめ言語構 文の中に組み込まれている格好である。そのため、項と継続を統一的に議論するのに適している と思われるが、これまで SLC についての研究はほとんどなされていない。そのひとつの原因は、 項と継続が双対であるという概念自体は明快であるものの、SLC の定式化としては Call-by-value 版の表示的意味記述が与えられているのみであり、簡約規則がないなど言語の基本的な挙動がわ かりにくく、したがって継続を扱う他のコントロールオペレータに比べて扱いにくかったことな どが考えられる。
